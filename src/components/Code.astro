---
import { LightRays } from "./ui/light-rays";
import { Marquee } from "./ui/marquee";
import { Icon } from "astro-icon/components";
import Repo from "./ui/Repo";
import { TextAnimate } from "./ui/text-animate";

async function getAllRepositories() {
    const isDev = import.meta.env.DEV;
    const cacheFile = ".cache/repositories.json";

    // Try to read from cache in development
    if (isDev) {
        try {
            const fs = await import("fs/promises");
            const path = await import("path");
            const cachePath = path.resolve(cacheFile);
            const cacheData = await fs.readFile(cachePath, "utf-8");
            const cached = JSON.parse(cacheData);

            // Cache for 1 hour
            const cacheAge = Date.now() - cached.timestamp;
            if (cacheAge < 60 * 60 * 1000) {
                console.log("Using cached repository data");
                return cached.data;
            }
        } catch (error) {
            // Cache doesn't exist or is invalid, continue to fetch
            console.log("No valid cache found, fetching from GitHub...");
        }
    }

    const QUERY = `query {
    viewer {
      repositories(first: 100, ownerAffiliations: OWNER, isFork: false, isArchived: false, orderBy: {field: UPDATED_AT, direction: DESC}) {
        nodes {
          name
          description
          url
          homepageUrl
          openGraphImageUrl
          isPrivate
          stargazerCount
          forkCount
          updatedAt
          primaryLanguage {
            name
            color
          }
          languages(first: 5) {
            nodes {
              name
            }
          }
        }
      }
    }
  }`;

    const res = await fetch("https://api.github.com/graphql", {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            Accept: "application/json",
            Authorization: `Bearer ${import.meta.env.ASTRO_GITHUB_TOKEN}`,
        },
        body: JSON.stringify({ query: QUERY }),
    });

    const json = await res.json();

    const repos = json.data.viewer.repositories.nodes;

    const data = repos
        .filter((repo: any) => repo.stargazerCount >= 1)
        .map((repo: any) => ({
            name: repo.name,
            body: repo.description || "",
            language: repo.primaryLanguage?.name,
            languageColor: repo.primaryLanguage?.color,
            starCount: repo.stargazerCount,
            forkCount: repo.forkCount,
            isPublic: !repo.isPrivate,
            updatedAt: repo.updatedAt,
        }));

    // Save to cache in development
    if (isDev) {
        try {
            const fs = await import("fs/promises");
            const path = await import("path");
            const cachePath = path.resolve(cacheFile);
            const cacheDir = path.dirname(cachePath);

            await fs.mkdir(cacheDir, { recursive: true });
            await fs.writeFile(
                cachePath,
                JSON.stringify({ timestamp: Date.now(), data }, null, 2),
                "utf-8",
            );
            console.log("Repository data cached");
        } catch (error) {
            console.error("Failed to write cache:", error);
        }
    }

    return data;
}

async function getForkedRepositories() {
    const isDev = import.meta.env.DEV;
    const cacheFile = ".cache/forks.json";

    // Try to read from cache in development
    if (isDev) {
        try {
            const fs = await import("fs/promises");
            const path = await import("path");
            const cachePath = path.resolve(cacheFile);
            const cacheData = await fs.readFile(cachePath, "utf-8");
            const cached = JSON.parse(cacheData);

            // Cache for 1 hour
            const cacheAge = Date.now() - cached.timestamp;
            if (cacheAge < 60 * 60 * 1000) {
                console.log("Using cached fork data");
                return cached.data;
            }
        } catch (error) {
            console.log("No valid fork cache found, fetching from GitHub...");
        }
    }

    const QUERY = `query {
    viewer {
      repositories(first: 100, ownerAffiliations: OWNER, isFork: true, isArchived: false, orderBy: {field: UPDATED_AT, direction: DESC}) {
        nodes {
          name
          description
          url
          homepageUrl
          openGraphImageUrl
          isPrivate
          stargazerCount
          forkCount
          updatedAt
          primaryLanguage {
            name
            color
          }
          languages(first: 5) {
            nodes {
              name
            }
          }
        }
      }
    }
  }`;

    const res = await fetch("https://api.github.com/graphql", {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            Accept: "application/json",
            Authorization: `Bearer ${import.meta.env.ASTRO_GITHUB_TOKEN}`,
        },
        body: JSON.stringify({ query: QUERY }),
    });

    const json = await res.json();

    const repos = json.data.viewer.repositories.nodes;

    const data = repos.map((repo: any) => ({
        name: repo.name,
        body: repo.description || "",
        language: repo.primaryLanguage?.name,
        languageColor: repo.primaryLanguage?.color,
        starCount: repo.stargazerCount,
        forkCount: repo.forkCount,
        isPublic: !repo.isPrivate,
        updatedAt: repo.updatedAt,
    }));

    // Save to cache in development
    if (isDev) {
        try {
            const fs = await import("fs/promises");
            const path = await import("path");
            const cachePath = path.resolve(cacheFile);
            const cacheDir = path.dirname(cachePath);

            await fs.mkdir(cacheDir, { recursive: true });
            await fs.writeFile(
                cachePath,
                JSON.stringify({ timestamp: Date.now(), data }, null, 2),
                "utf-8",
            );
            console.log("Fork data cached");
        } catch (error) {
            console.error("Failed to write fork cache:", error);
        }
    }

    return data;
}

const repositories = await getAllRepositories();
const forks = await getForkedRepositories();

const firstRow = repositories.slice(0, repositories.length / 2);
const secondRow = repositories.slice(repositories.length / 2);

const forksFirstRow = forks.slice(0, forks.length / 2);
const forksSecondRow = forks.slice(forks.length / 2);
---

<!-- <Font cssVariable="--font-inter" preload /> -->
<div class="h-screen w-full py-4" id="code">
    <h1 class="text-6xl font-bold text-center mb-16 hover-glow">
        <a href="https://github.com/ThatXliner?tab=repositories"
            >My Code <Icon name="lucide:external-link" class="inline" /></a
        >
    </h1>
    <div class="flex w-full justify-center">
        <p
            class="w-full text-center text-lg text-slate-800/80 md:text-xl dark:text-slate-200/80 italic"
        >
            <TextAnimate
                animation="blurIn"
                as="h3"
                client:only
                text={"Source Repositories: Projects I've started myself"}
            />
        </p>
    </div>

    <div
        class="relative flex w-full flex-col items-center justify-center overflow-hidden mt-8"
    >
        <Marquee client:only pauseOnHover className="[--duration:90s]">
            {firstRow.map((review) => <Repo client:only {...review} />)}
        </Marquee>
        <Marquee client:only reverse pauseOnHover className="[--duration:90s]">
            {secondRow.map((review) => <Repo client:only {...review} />)}
        </Marquee>
        <div
            class="from-background pointer-events-none absolute inset-y-0 left-0 w-1/4 bg-linear-to-r"
        >
        </div>
        <div
            class="from-background pointer-events-none absolute inset-y-0 right-0 w-1/4 bg-linear-to-l"
        >
        </div>
    </div>

    <div class="flex w-full justify-center">
        <p
            class="w-full text-center text-lg text-slate-800/80 md:text-xl dark:text-slate-200/80 italic"
        >
            <TextAnimate
                animation="blurIn"
                as="h3"
                client:only
                text={"Forks: My contributions to OSS"}
            />
        </p>
    </div>

    <div
        class="relative flex w-full flex-col items-center justify-center overflow-hidden mt-8"
    >
        <Marquee client:only pauseOnHover className="[--duration:120s]">
            {forksFirstRow.map((review) => <Repo client:only {...review} />)}
        </Marquee>
        <Marquee client:only reverse pauseOnHover className="[--duration:120s]">
            {forksSecondRow.map((review) => <Repo client:only {...review} />)}
        </Marquee>
        <div
            class="from-background pointer-events-none absolute inset-y-0 left-0 w-1/4 bg-gradient-to-r"
        >
        </div>
        <div
            class="from-background pointer-events-none absolute inset-y-0 right-0 w-1/4 bg-gradient-to-l"
        >
        </div>
    </div>
    <LightRays />
</div>
